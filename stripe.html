<html>
<head>
    <meta charset=utf-8>
    <title>Earth Model</title>
    <style>
        body { margin: 0;
        background-image: url("images/galaxy_starfield.png")  ; 
        background: rgb(155,154,195);
background: radial-gradient(circle, rgba(155,154,195,1) 8%, rgba(17,38,106,1) 87%);
}
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
   <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/d3-array@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-geo@3"></script>
    <script> 
    //change if it is night or day
    const night = true;
    const speed = 0.001;
    //constants 
    const GLOBE_RADIUS = 1.7;
    const CURVE_MIN_ALTITUDE = 0.2;
    const CURVE_MAX_ALTITUDE = 0.7;
    const DEGREE_TO_RADIAN = Math.PI / 180;
    var geoInterpolate = d3.geoInterpolate;
    var group = new THREE.Group();
    var newcords = [[-33.96979014620984, 18.563199614709422],[48.724518664223766, 9.177911250908913],[51.615877000440264, 0.31109813001910297],[38.09154483768071, -122.53560966845991],[28.815048591863633, -81.64619331594027],[39.541762576156515, -86.2100444795997],[40.432120644575924, -80.00075710858884],[47.62069082653115, -122.31456952905911],[18.77979378012541, 98.98159008655102],[-27.497555531779742, 152.9274897956595],[-22.898860476802746, -43.48925732759966]];
    //var newcords = [[-22.910898250743873, -43.5331953727039],[55.58564620043719, 13.077589635425625],[48.917267675145744, 9.261940280040854],[-22.910898250743873, -43.5331953727039]];
    function clamp(num, min, max) {
  return num <= min ? min : (num >= max ? max : num);
}
function coordinateToPosition(lat, lng, radius) {
  const phi = (90 - lat) * DEGREE_TO_RADIAN;
  const theta = (lng + 180) * DEGREE_TO_RADIAN;

  return new THREE.Vector3(
    - radius * Math.sin(phi) * Math.cos(theta),
    radius * Math.cos(phi),
    radius * Math.sin(phi) * Math.sin(theta)
  );
}
function getSplineFromCoords(coords) {
  const startLat = coords[0];
  const startLng = coords[1];
  const endLat = coords[2];
  const endLng = coords[3];

  // start and end points
  const start = coordinateToPosition(startLat, startLng, GLOBE_RADIUS);
  const end = coordinateToPosition(endLat, endLng, GLOBE_RADIUS);
  
  // altitude
  const altitude = clamp(start.distanceTo(end) * .75, CURVE_MIN_ALTITUDE, CURVE_MAX_ALTITUDE);
  
  // 2 control points
  const interpolate = geoInterpolate([startLng, startLat], [endLng, endLat]);
  const midCoord1 = interpolate(0.25);
  const midCoord2 = interpolate(0.75);
  const mid1 = coordinateToPosition(midCoord1[1], midCoord1[0], GLOBE_RADIUS + altitude);
  const mid2 = coordinateToPosition(midCoord2[1], midCoord2[0], GLOBE_RADIUS + altitude);

  return {
    start,
    end,
    spline: new THREE.CubicBezierCurve3(start, mid1, mid2, end)
  };
}
    //Scene Setup
     var scene = new THREE.Scene();
     var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
     var renderer = new THREE.WebGLRenderer({ antialias: false,alpha:true });
     renderer.setSize( 1920  , 1080 );
     document.body.appendChild( renderer.domElement );
     var corecube = new THREE.SphereGeometry(1.7, 32, 32);
     var corecubeMaterial = new THREE.MeshPhongMaterial();
     var texture = night ? 'images/earthlights10k.jpg' : 'images/earthmap10k.jpg';
     corecubeMaterial.map = new THREE.TextureLoader().load(texture);
     corecubeMaterial.bumpMap   = new THREE.TextureLoader().load('images/earthbump10k.jpg');     
     corecubeMaterial.bumpScale = 0.05;
     corecubeMaterial.specularMap = new THREE.TextureLoader().load('images/earthspec1k.jpg')
     corecubeMaterial.specular  = new THREE.Color('white')
     //make specular less
      corecubeMaterial.shininess = 0.1;
    var corecubeMesh = new THREE.Mesh( corecube, corecubeMaterial );
    scene.add( corecubeMesh );    
    //light
    var light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(0,3,5);
    scene.add(light);
     
      //wirecube
      var wirecube = new THREE.SphereGeometry( 2, 20,20 );
      var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } )
      var cube = new THREE.Mesh( wirecube, material );
      

      //convert into wireframe 
      var wireframe = new THREE.WireframeGeometry( wirecube ); 
      let line = new THREE.LineSegments( wireframe );
					line.material.opacity = 1;
					line.material.transparent = true;
      //scene.add( line );
      camera.position.z = 3;
      camera.position.y = 1.5;
      //rotate camera down 
      camera.rotation.x = -0.45;
      //create point to point curve
     function drawCords(){
      
      
      for(let i=0; i < newcords.length; i++){
        console.log(newcords[i]);
        let prev = i == 0 ? 1 : i-1;
        let cords = [newcords[prev][0],newcords[prev][1],newcords[i][0],newcords[i][1]];
        let spline = getSplineFromCoords(cords);
        console.log(cords,spline);
        /*let curve1 = new THREE.TubeGeometry(spline.spl, 50, 0.1, 8, false);
        let curve1mesh = new THREE.Mesh(curve1, new THREE.MeshBasicMaterial({color: 0xf56042}));
        scene.add(curve1mesh);*/
        let curvegeo = new THREE.Geometry();
        curvegeo.vertices = spline.spline.getPoints(50);
        let curve1 = new THREE.Line(curvegeo, new THREE.LineBasicMaterial({color: 0xffffff,linewidth:2}));
        group.add(curve1);	
      }
      scene.add(group);
      
    }
drawCords()

//animations
      var animate = function () {
	    requestAnimationFrame( animate );

      corecubeMesh.rotation.y += speed;
      line.rotation.y += speed;
      group.rotation.y += speed;
      renderer.render( scene, camera );
      };
      //corecubeMesh.rotation.x += 0.5;

      animate();
      renderer.setClearColor(0x000000, 0);


          </script>
    </script>
</body>
</html>