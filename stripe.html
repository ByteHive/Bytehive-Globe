<html>
<head>
    <meta charset=utf-8>
    <title>Earth Model</title>
    <style>
        body { margin: 0;
        background-image: url("images/galaxy_starfield.png")  ; 
        background: rgb(155,154,195);
background: radial-gradient(circle, rgba(155,154,195,1) 8%, rgba(17,38,106,1) 87%);
}
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
   <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/d3-array@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-geo@3"></script>
    <script> 
    var nEnd = 0, nMax, nStep = 50;
    var currentmesh,cordID = 0;
    //change if it is night or day
    const night = true;
    const speed = 0.001;
    //constants 
    const GLOBE_RADIUS = 1.7;
    const CURVE_MIN_ALTITUDE = 0.2;
    const CURVE_MAX_ALTITUDE = 0.7;
    const DEGREE_TO_RADIAN = Math.PI / 180;
    var geoInterpolate = d3.geoInterpolate;
    var group = new THREE.Group();
    var newcords = [[32.84933420904412, -117.11577306665959],[39.72936785474714, -75.55077098697406],[32.79577328681345, -96.85859304830119],[25.779620175815072, -80.24902866896761],[40.38979221753041, -80.0759306084545],[36.10492482949355, -115.2347647152365],[36.100871478361356, -115.22378599103946],[33.8835405111569, -117.93040066577963],[43.06691162583355, -89.4366459433431],[33.763976458438925, -84.45081967319514],[37.75551835028943, -122.43828775339452],[38.075071713959886, -122.5635962456642],[48.77578510540918, 9.153178256887925],[-33.95493009464746, 18.587481669495357],[34.85608049747699, 136.7582077042448],[30.379978809139967, 531.711540043]];
    var lastCords = [0,0];
    //var newcords = [[-22.910898250743873, -43.5331953727039],[55.58564620043719, 13.077589635425625],[48.917267675145744, 9.261940280040854],[-22.910898250743873, -43.5331953727039]];
    function clamp(num, min, max) {
  return num <= min ? min : (num >= max ? max : num);
}
function coordinateToPosition(lat, lng, radius) {
  const phi = (90 - lat) * DEGREE_TO_RADIAN;
  const theta = (lng + 180) * DEGREE_TO_RADIAN;

  return new THREE.Vector3(
    - radius * Math.sin(phi) * Math.cos(theta),
    radius * Math.cos(phi),
    radius * Math.sin(phi) * Math.sin(theta)
  );
}
function getSplineFromCoords(coords) {
  const startLat = coords[0];
  const startLng = coords[1];
  const endLat = coords[2];
  const endLng = coords[3];

  // start and end points
  const start = coordinateToPosition(startLat, startLng, GLOBE_RADIUS);
  const end = coordinateToPosition(endLat, endLng, GLOBE_RADIUS);
  
  // altitude
  const altitude = clamp(start.distanceTo(end) * .75, CURVE_MIN_ALTITUDE, CURVE_MAX_ALTITUDE);
  
  // 2 control points
  const interpolate = geoInterpolate([startLng, startLat], [endLng, endLat]);
  const midCoord1 = interpolate(0.25);
  const midCoord2 = interpolate(0.75);
  const mid1 = coordinateToPosition(midCoord1[1], midCoord1[0], GLOBE_RADIUS + altitude);
  const mid2 = coordinateToPosition(midCoord2[1], midCoord2[0], GLOBE_RADIUS + altitude);

  return {
    start,
    end,
    spline: new THREE.CubicBezierCurve3(start, mid1, mid2, end)
  };
}
    //Scene Setup
     var scene = new THREE.Scene();
     var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
     var renderer = new THREE.WebGLRenderer({ antialias: false,alpha:true });
     renderer.setSize( 1920  , 1080 );
     document.body.appendChild( renderer.domElement );
     var corecube = new THREE.SphereGeometry(1.7, 32, 32);
     var corecubeMaterial = new THREE.MeshPhongMaterial();
     var texture = night ? 'images/earthlights10k.jpg' : 'images/earthmap10k.jpg';
     corecubeMaterial.map = new THREE.TextureLoader().load(texture);
     corecubeMaterial.bumpMap   = new THREE.TextureLoader().load('images/earthbump10k.jpg');     
     corecubeMaterial.bumpScale = 0.05;
     corecubeMaterial.specularMap = new THREE.TextureLoader().load('images/earthspec1k.jpg')
     corecubeMaterial.specular  = new THREE.Color('white')
     //make specular less
      corecubeMaterial.shininess = 0.1;
    var corecubeMesh = new THREE.Mesh( corecube, corecubeMaterial );
    scene.add( corecubeMesh );    
    //light
    var light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(0,3,5);
    scene.add(light);
     
      //wirecube
      var wirecube = new THREE.SphereGeometry( 2, 20,20 );
      var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } )
      var cube = new THREE.Mesh( wirecube, material );
      

      //convert into wireframe 
      var wireframe = new THREE.WireframeGeometry( wirecube ); 
      let line = new THREE.LineSegments( wireframe );
					line.material.opacity = 1;
					line.material.transparent = true;
      //scene.add( line );
      camera.position.z = 3;
      camera.position.y = 1.5;
      //rotate camera down 
      camera.rotation.x = -0.45;
      //create point to point curve
     function drawCords(newCords){

      
        let cords = [lastCords[0],lastCords[1],newCords[0],newCords[1]];
        let spline = getSplineFromCoords(cords);
        console.log(cords,spline);
        let tube = new THREE.TubeGeometry(spline.spline, 50, 0.006, 8, false);
        let buffer = new THREE.BufferGeometry().fromGeometry( tube );
        let tubematerial = new THREE.MeshBasicMaterial({color: 0x55ffff});	
        currentmesh = new THREE.Mesh(buffer, tubematerial);

        nMax = buffer.attributes.position.count;
        currentmesh.geometry.setDrawRange( 0, 0 );
        group.add(currentmesh);	
        lastCords = newCords;
      
      
    }
drawCords([30,30])
scene.add(group);

//animations
      var animate = function () {
	    requestAnimationFrame( animate );

      corecubeMesh.rotation.y += speed;
      line.rotation.y += speed;
      group.rotation.y += speed;
      if( nEnd < nMax){
        console.log("Drawing next Step")
      nEnd = ( nEnd + nStep ) ;
      currentmesh.geometry.setDrawRange( 0, nEnd );
      }else{
        //console.log("End of animation")
        if(cordID+1 != newcords.length-1){
        console.log("There is aqnother one")
        cordID++;
        nEnd = 0;	
        drawCords(newcords[cordID]);
        }else{
         // console.log("No more cords")
        }
      }

      renderer.render( scene, camera );
      };
      //corecubeMesh.rotation.x += 0.5;

      animate();
      renderer.setClearColor(0x000000, 0);

          </script>
    </script>
</body> 
</html>